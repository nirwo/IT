const Cluster = require('../models/Cluster');
const ESXiHost = require('../models/ESXiHost');
const AllocationProfile = require('../models/AllocationProfile');
const VDI = require('../models/VDI');
const CapacityCalculationService = require('../services/capacityCalculationService');
const logger = require('../config/logger');
const Joi = require('joi');

const capacityService = new CapacityCalculationService();

const getClusters = async (req, res) => {
  try {
    const schema = Joi.object({
      page: Joi.number().integer().min(1).default(1),
      limit: Joi.number().integer().min(1).max(100).default(20),
      includeInactive: Joi.boolean().default(false)
    });

    const { error, value } = schema.validate(req.query);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const { page, limit, includeInactive } = value;

    let query = {};
    if (req.user.organization.type !== 'admin') {
      query.organization = req.user.organization._id;
    }

    if (!includeInactive) {
      query.isActive = true;
    }

    const skip = (page - 1) * limit;

    const [clusters, total] = await Promise.all([
      Cluster.find(query)
        .skip(skip)
        .limit(limit)
        .populate('organization', 'name type')
        .lean(),
      Cluster.countDocuments(query)
    ]);

    // Add utilization and host information
    const clustersWithStats = await Promise.all(
      clusters.map(async (cluster) => {
        const hostCount = await ESXiHost.countDocuments({
          cluster: cluster._id,
          isActive: true
        });

        const clusterModel = new Cluster(cluster);
        const utilization = clusterModel.getUtilization();
        clusterModel.calculateAvailableCapacity();

        return {
          ...cluster,
          utilization,
          hostCount,
          availableCapacity: clusterModel.capacity.available
        };
      })
    );

    res.json({
      clusters: clustersWithStats,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    logger.error('Error fetching clusters:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const getCluster = async (req, res) => {
  try {
    const { id } = req.params;

    const cluster = await Cluster.findById(id)
      .populate('organization', 'name type');

    if (!cluster) {
      return res.status(404).json({ error: 'Cluster not found' });
    }

    if (req.user.organization.type !== 'admin' && 
        cluster.organization._id.toString() !== req.user.organization._id.toString()) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const [hosts, profiles] = await Promise.all([
      ESXiHost.find({ cluster: id, isActive: true })
        .select('name hostname capacity utilization connectionState powerState maintenanceMode')
        .lean(),
      AllocationProfile.find({ cluster: id, isActive: true })
        .select('name resourceSpecs allocation utilizationStats autoGenerated')
        .lean()
    ]);

    const utilization = cluster.getUtilization();
    cluster.calculateAvailableCapacity();

    res.json({
      cluster: {
        ...cluster.toObject(),
        utilization,
        availableCapacity: cluster.capacity.available
      },
      hosts,
      profiles
    });
  } catch (error) {
    logger.error('Error fetching cluster:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const getAllocationProfiles = async (req, res) => {
  try {
    const schema = Joi.object({
      clusterId: Joi.string().pattern(/^[0-9a-fA-F]{24}$/),
      autoGenerated: Joi.boolean(),
      sortBy: Joi.string().valid('name', 'createdAt', 'allocation.current.count').default('name'),
      sortOrder: Joi.string().valid('asc', 'desc').default('asc')
    });

    const { error, value } = schema.validate(req.query);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const { clusterId, autoGenerated, sortBy, sortOrder } = value;

    let query = { isActive: true };
    
    if (req.user.organization.type !== 'admin') {
      query.organization = req.user.organization._id;
    }

    if (clusterId) {
      query.cluster = clusterId;
    }

    if (typeof autoGenerated === 'boolean') {
      query.autoGenerated = autoGenerated;
    }

    const sort = {};
    sort[sortBy] = sortOrder === 'desc' ? -1 : 1;

    const profiles = await AllocationProfile.find(query)
      .sort(sort)
      .populate('cluster', 'name')
      .populate('organization', 'name')
      .lean();

    // Add available slots and efficiency calculations
    const profilesWithStats = profiles.map(profile => {
      const profileModel = new AllocationProfile(profile);
      return {
        ...profile,
        availableSlots: profileModel.getAvailableSlots(),
        efficiency: profileModel.utilizationStats.efficiency || 0
      };
    });

    res.json({ profiles: profilesWithStats });
  } catch (error) {
    logger.error('Error fetching allocation profiles:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const getCapacityStatus = async (req, res) => {
  try {
    const status = await capacityService.getAllocationsStatus(req.user.organization._id);
    res.json(status);
  } catch (error) {
    logger.error('Error fetching capacity status:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const recalculateCapacity = async (req, res) => {
  try {
    const { clusterId } = req.params;

    const cluster = await Cluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ error: 'Cluster not found' });
    }

    if (req.user.organization.type !== 'admin' && 
        cluster.organization.toString() !== req.user.organization._id.toString()) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const updatedCluster = await capacityService.calculateClusterCapacity(clusterId);
    
    logger.info(`Capacity recalculated for cluster ${cluster.name} by ${req.user.username}`);

    res.json({
      message: 'Capacity recalculated successfully',
      cluster: {
        id: updatedCluster._id,
        name: updatedCluster.name,
        capacity: updatedCluster.capacity,
        utilization: updatedCluster.getUtilization()
      }
    });
  } catch (error) {
    logger.error('Error recalculating capacity:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const generateAutoProfiles = async (req, res) => {
  try {
    const { clusterId } = req.params;

    const cluster = await Cluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ error: 'Cluster not found' });
    }

    if (req.user.organization.type !== 'admin' && 
        cluster.organization.toString() !== req.user.organization._id.toString()) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const profiles = await capacityService.generateAutomaticProfiles(clusterId);
    
    logger.info(`Generated ${profiles.length} automatic profiles for cluster ${cluster.name} by ${req.user.username}`);

    res.json({
      message: `Generated ${profiles.length} automatic profiles`,
      profiles: profiles.map(profile => ({
        id: profile._id,
        name: profile.name,
        resourceSpecs: profile.resourceSpecs,
        allocation: profile.allocation,
        instanceCount: profile.instances.length
      }))
    });
  } catch (error) {
    logger.error('Error generating automatic profiles:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const getCapacityRecommendations = async (req, res) => {
  try {
    const { clusterId } = req.params;

    const cluster = await Cluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ error: 'Cluster not found' });
    }

    if (req.user.organization.type !== 'admin' && 
        cluster.organization.toString() !== req.user.organization._id.toString()) {
      return res.status(403).json({ error: 'Access denied' });
    }

    const recommendations = await capacityService.getCapacityRecommendations(clusterId);

    res.json({
      cluster: {
        id: cluster._id,
        name: cluster.name
      },
      recommendations
    });
  } catch (error) {
    logger.error('Error fetching capacity recommendations:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const getAllocationProfile = async (req, res) => {
  try {
    const { id } = req.params;

    const profile = await AllocationProfile.findById(id)
      .populate('cluster', 'name capacity')
      .populate('organization', 'name');

    if (!profile) {
      return res.status(404).json({ error: 'Allocation profile not found' });
    }

    if (req.user.organization.type !== 'admin' && 
        profile.organization._id.toString() !== req.user.organization._id.toString()) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Calculate current maximum allocation
    await profile.calculateMaxAllocation();
    
    // Get detailed instance information
    const instances = await Promise.all(
      profile.instances.map(async (instance) => {
        const vdi = await VDI.findById(instance.vdiId)
          .select('ciName assignedUser status esxiHost lastSeen')
          .lean();
        
        return {
          ...instance,
          vdiDetails: vdi
        };
      })
    );

    res.json({
      profile: {
        ...profile.toObject(),
        availableSlots: profile.getAvailableSlots(),
        instances
      }
    });
  } catch (error) {
    logger.error('Error fetching allocation profile:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const createAllocationProfile = async (req, res) => {
  try {
    const schema = Joi.object({
      name: Joi.string().required().trim().min(1).max(100),
      clusterId: Joi.string().pattern(/^[0-9a-fA-F]{24}$/).required(),
      resourceSpecs: Joi.object({
        cpu: Joi.object({
          cores: Joi.number().integer().min(1).max(64).required(),
          mhz: Joi.number().integer().min(1000).required()
        }).required(),
        memory: Joi.object({
          mb: Joi.number().integer().min(512).required()
        }).required(),
        storage: Joi.object({
          gb: Joi.number().integer().min(10).required()
        }).required()
      }).required(),
      targetCount: Joi.number().integer().min(0).default(0),
      tags: Joi.array().items(Joi.string().trim()).default([])
    });

    const { error, value } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const { name, clusterId, resourceSpecs, targetCount, tags } = value;

    // Verify cluster exists and user has access
    const cluster = await Cluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ error: 'Cluster not found' });
    }

    if (req.user.organization.type !== 'admin' && 
        cluster.organization.toString() !== req.user.organization._id.toString()) {
      return res.status(403).json({ error: 'Access denied to cluster' });
    }

    // Check for existing profile with same name
    const existingProfile = await AllocationProfile.findOne({
      name,
      cluster: clusterId,
      isActive: true
    });

    if (existingProfile) {
      return res.status(409).json({ error: 'Profile with this name already exists in cluster' });
    }

    const profile = new AllocationProfile({
      name,
      organization: req.user.organization._id,
      cluster: clusterId,
      resourceSpecs,
      allocation: {
        target: { count: targetCount }
      },
      tags,
      autoGenerated: false
    });

    // Calculate maximum allocation
    await profile.calculateMaxAllocation();
    await profile.save();

    logger.info(`Allocation profile "${name}" created by ${req.user.username}`);

    res.status(201).json({
      profile: {
        ...profile.toObject(),
        availableSlots: profile.getAvailableSlots()
      }
    });
  } catch (error) {
    logger.error('Error creating allocation profile:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

const updateAllocationProfile = async (req, res) => {
  try {
    const schema = Joi.object({
      name: Joi.string().trim().min(1).max(100),
      resourceSpecs: Joi.object({
        cpu: Joi.object({
          cores: Joi.number().integer().min(1).max(64),
          mhz: Joi.number().integer().min(1000)
        }),
        memory: Joi.object({
          mb: Joi.number().integer().min(512)
        }),
        storage: Joi.object({
          gb: Joi.number().integer().min(10)
        })
      }),
      targetCount: Joi.number().integer().min(0),
      tags: Joi.array().items(Joi.string().trim()),
      isActive: Joi.boolean()
    });

    const { error, value } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({ error: error.details[0].message });
    }

    const { id } = req.params;
    const profile = await AllocationProfile.findById(id);

    if (!profile) {
      return res.status(404).json({ error: 'Allocation profile not found' });
    }

    if (req.user.organization.type !== 'admin' && 
        profile.organization.toString() !== req.user.organization._id.toString()) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Check for name conflicts if name is being changed
    if (value.name && value.name !== profile.name) {
      const existingProfile = await AllocationProfile.findOne({
        name: value.name,
        cluster: profile.cluster,
        isActive: true,
        _id: { $ne: id }
      });

      if (existingProfile) {
        return res.status(409).json({ error: 'Profile with this name already exists in cluster' });
      }
    }

    // Update profile
    Object.assign(profile, value);
    profile.lastCalculated = new Date();

    // Recalculate maximum allocation if resource specs changed
    if (value.resourceSpecs) {
      await profile.calculateMaxAllocation();
    }

    await profile.save();

    logger.info(`Allocation profile "${profile.name}" updated by ${req.user.username}`);

    res.json({
      profile: {
        ...profile.toObject(),
        availableSlots: profile.getAvailableSlots()
      }
    });
  } catch (error) {
    logger.error('Error updating allocation profile:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
};

module.exports = {
  getClusters,
  getCluster,
  getAllocationProfiles,
  getAllocationProfile,
  createAllocationProfile,
  updateAllocationProfile,
  getCapacityStatus,
  recalculateCapacity,
  generateAutoProfiles,
  getCapacityRecommendations
};