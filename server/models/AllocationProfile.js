const mongoose = require('mongoose');

const allocationProfileSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  organization: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Organization',
    required: true
  },
  cluster: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Cluster',
    required: true
  },
  resourceSpecs: {
    cpu: {
      cores: {
        type: Number,
        required: true,
        min: 1
      },
      mhz: {
        type: Number,
        required: true
      }
    },
    memory: {
      mb: {
        type: Number,
        required: true,
        min: 512
      }
    },
    storage: {
      gb: {
        type: Number,
        required: true,
        min: 10
      }
    }
  },
  allocation: {
    current: {
      count: {
        type: Number,
        default: 0
      },
      resources: {
        cpu: {
          cores: {
            type: Number,
            default: 0
          },
          mhz: {
            type: Number,
            default: 0
          }
        },
        memory: {
          mb: {
            type: Number,
            default: 0
          }
        },
        storage: {
          gb: {
            type: Number,
            default: 0
          }
        }
      }
    },
    maximum: {
      count: {
        type: Number,
        default: 0
      },
      limitedBy: {
        type: String,
        enum: ['cpu', 'memory', 'storage', 'none'],
        default: 'none'
      }
    },
    target: {
      count: {
        type: Number,
        default: 0
      }
    }
  },
  instances: [{
    vdiId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'VDI'
    },
    vmId: String,
    ciName: String,
    assignedUser: String,
    status: {
      type: String,
      enum: ['active', 'inactive', 'provisioning', 'maintenance']
    },
    esxiHost: String,
    allocatedAt: {
      type: Date,
      default: Date.now
    }
  }],
  utilizationStats: {
    average: {
      cpu: {
        type: Number,
        default: 0
      },
      memory: {
        type: Number,
        default: 0
      },
      storage: {
        type: Number,
        default: 0
      }
    },
    peak: {
      cpu: {
        type: Number,
        default: 0
      },
      memory: {
        type: Number,
        default: 0
      },
      storage: {
        type: Number,
        default: 0
      }
    },
    efficiency: {
      type: Number,
      default: 0,
      min: 0,
      max: 100
    }
  },
  autoGenerated: {
    type: Boolean,
    default: false
  },
  tags: [String],
  isActive: {
    type: Boolean,
    default: true
  },
  lastCalculated: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

allocationProfileSchema.index({ organization: 1, cluster: 1 });
allocationProfileSchema.index({ 'resourceSpecs.cpu.cores': 1, 'resourceSpecs.memory.mb': 1 });
allocationProfileSchema.index({ autoGenerated: 1, isActive: 1 });

allocationProfileSchema.methods.calculateMaxAllocation = async function() {
  const Cluster = require('./Cluster');
  const cluster = await Cluster.findById(this.cluster);
  
  if (!cluster) {
    return { count: 0, limitedBy: 'none' };
  }

  cluster.calculateAvailableCapacity();
  
  const maxByCpu = Math.floor(cluster.capacity.available.cpu.cores / this.resourceSpecs.cpu.cores);
  const maxByMemory = Math.floor(cluster.capacity.available.memory.mb / this.resourceSpecs.memory.mb);
  const maxByStorage = Math.floor(cluster.capacity.available.storage.gb / this.resourceSpecs.storage.gb);
  
  const maxCount = Math.min(maxByCpu, maxByMemory, maxByStorage);
  
  let limitedBy = 'none';
  if (maxCount === maxByCpu && maxByCpu <= maxByMemory && maxByCpu <= maxByStorage) {
    limitedBy = 'cpu';
  } else if (maxCount === maxByMemory && maxByMemory <= maxByStorage) {
    limitedBy = 'memory';
  } else if (maxCount === maxByStorage) {
    limitedBy = 'storage';
  }
  
  this.allocation.maximum = {
    count: maxCount,
    limitedBy: limitedBy
  };
  
  return this.allocation.maximum;
};

allocationProfileSchema.methods.addInstance = function(vdiData) {
  const existingIndex = this.instances.findIndex(inst => inst.vdiId.toString() === vdiData.vdiId.toString());
  
  if (existingIndex >= 0) {
    this.instances[existingIndex] = { ...this.instances[existingIndex], ...vdiData };
  } else {
    this.instances.push(vdiData);
  }
  
  this.updateAllocationCounts();
};

allocationProfileSchema.methods.removeInstance = function(vdiId) {
  this.instances = this.instances.filter(inst => inst.vdiId.toString() !== vdiId.toString());
  this.updateAllocationCounts();
};

allocationProfileSchema.methods.updateAllocationCounts = function() {
  const activeInstances = this.instances.filter(inst => inst.status === 'active');
  
  this.allocation.current = {
    count: activeInstances.length,
    resources: {
      cpu: {
        cores: activeInstances.length * this.resourceSpecs.cpu.cores,
        mhz: activeInstances.length * this.resourceSpecs.cpu.mhz
      },
      memory: {
        mb: activeInstances.length * this.resourceSpecs.memory.mb
      },
      storage: {
        gb: activeInstances.length * this.resourceSpecs.storage.gb
      }
    }
  };
};

allocationProfileSchema.methods.getAvailableSlots = function() {
  return Math.max(0, this.allocation.maximum.count - this.allocation.current.count);
};

allocationProfileSchema.methods.calculateUtilizationEfficiency = function() {
  if (this.allocation.current.count === 0) {
    this.utilizationStats.efficiency = 0;
    return 0;
  }

  const avgUtilization = (
    this.utilizationStats.average.cpu +
    this.utilizationStats.average.memory +
    this.utilizationStats.average.storage
  ) / 3;

  this.utilizationStats.efficiency = avgUtilization;
  return avgUtilization;
};

allocationProfileSchema.statics.findSimilarProfiles = function(resourceSpecs, tolerance = 0.1) {
  const cpuRange = resourceSpecs.cpu.cores * tolerance;
  const memoryRange = resourceSpecs.memory.mb * tolerance;
  
  return this.find({
    'resourceSpecs.cpu.cores': {
      $gte: resourceSpecs.cpu.cores - cpuRange,
      $lte: resourceSpecs.cpu.cores + cpuRange
    },
    'resourceSpecs.memory.mb': {
      $gte: resourceSpecs.memory.mb - memoryRange,
      $lte: resourceSpecs.memory.mb + memoryRange
    },
    isActive: true
  });
};

module.exports = mongoose.model('AllocationProfile', allocationProfileSchema);